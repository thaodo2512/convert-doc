import yaml
import json
import struct
import argparse
import sys
import os
import glob
from datetime import datetime

# Mapping PLDM/YAML types to Python struct formats (Little Endian)
TYPE_MAP = {
    'uint8': 'B', 'int8': 'b', 'enum8': 'B', 'bitfield8': 'B', 'bool': '?',
    'uint16': '<H', 'int16': '<h',
    'uint32': '<I', 'int32': '<i',
    'float': '<f', 'real32': '<f',
    'uint64': '<Q', 'int64': '<q',
    'uuid': 'B'
}

def get_value_and_type(node):
    if isinstance(node, dict):
        if 'value' in node:
            return node['value'], node.get('type', 'uint8')
        else:
            return node, 'struct'
    return node, 'uint8'

def pack_simple(val, type_name):
    try:
        if isinstance(val, list):
            fmt = TYPE_MAP.get(type_name, 'B')
            packed = bytearray()
            for item in val:
                packed.extend(struct.pack(fmt, item))
            return packed
        if type_name == 'bool':
            return struct.pack('?', bool(val))
        fmt = TYPE_MAP.get(type_name, 'B')
        return struct.pack(fmt, val)
    except Exception as e:
        print(f"ERROR: Packing value '{val}' as '{type_name}': {e}")
        sys.exit(1)

def pack_node(node):
    val, dtype = get_value_and_type(node)
    if dtype == 'struct':
        packed = bytearray()
        for key in val:
            packed.extend(pack_node(val[key]))
        return packed
    else:
        return pack_simple(val, dtype)

def process_single_yaml(yaml_path, schema_dir):
    filename = os.path.basename(yaml_path)
    var_name = os.path.splitext(filename)[0].replace('-', '_').replace(' ', '_')
    
    with open(yaml_path, 'r') as f:
        data = yaml.safe_load(f)

    # 1. Determine PDR Type to find the Schema
    try:
        pdr_type = data['pdrHeader']['PDRType']['value']
    except KeyError:
        print(f"Skipping {filename}: Could not find 'pdrHeader.PDRType.value'")
        return None, None

    schema_filename = f"type_{pdr_type}.json"
    schema_path = os.path.join(schema_dir, schema_filename)

    if not os.path.exists(schema_path):
        print(f"Error processing {filename}: Schema '{schema_filename}' not found in {schema_dir}")
        sys.exit(1)

    with open(schema_path, 'r') as f:
        schema = json.load(f)

    # 2. Pack Data
    byte_buffer = bytearray()
    
    # Header
    header = data.get('pdrHeader', {})
    for field in ['recordHandle', 'PDRHeaderVersion', 'PDRType', 'recordChangeNumber', 'dataLength']:
        if field in header:
            byte_buffer.extend(pack_node(header[field]))
        else:
            print(f"Error {filename}: Missing header field '{field}'")
            sys.exit(1)

    # Body
    if 'binaryOrder' in schema:
        for field in schema['binaryOrder']:
            if field in data:
                byte_buffer.extend(pack_node(data[field]))
            else:
                print(f"Error {filename}: Missing field '{field}' in data")
                sys.exit(1)
    else:
        print(f"Error {filename}: Schema {schema_filename} missing 'binaryOrder'")
        sys.exit(1)

    print(f"  - Processed {filename} (Type {pdr_type}) -> {len(byte_buffer)} bytes")
    return byte_buffer, var_name

def generate_all(yaml_dir, schema_dir, output_file):
    if not os.path.exists(yaml_dir):
        print(f"YAML Directory not found: {yaml_dir}")
        sys.exit(1)

    yaml_files = glob.glob(os.path.join(yaml_dir, "*.yaml"))
    if not yaml_files:
        print("No .yaml files found in directory.")
        sys.exit(0)

    print(f"Found {len(yaml_files)} YAML files in {yaml_dir}")

    generated_arrays = [] # List of (var_name, size)

    # Start C File Content
    c_source = [
        "/*",
        f" * Generated by code_gen_dir.py",
        f" * Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        " */",
        "",
        "#include <stdint.h>",
        "#include <stddef.h>",
        ""
    ]

    # Process each file
    for yaml_file in sorted(yaml_files):
        byte_data, var_name = process_single_yaml(yaml_file, schema_dir)
        if byte_data:
            # Add array definition
            c_source.append(f"// Source: {os.path.basename(yaml_file)}")
            c_source.append(f"const uint8_t {var_name}[] = {{")
            
            # Hex formatting
            hex_lines = []
            for i in range(0, len(byte_data), 12):
                chunk = byte_data[i:i + 12]
                hex_lines.append("    " + ", ".join(f"0x{b:02X}" for b in chunk) + ",")
            
            # Remove last comma for C strictness
            if hex_lines: hex_lines[-1] = hex_lines[-1].rstrip(',')
            
            c_source.extend(hex_lines)
            c_source.append("};")
            c_source.append(f"const size_t {var_name}_size = sizeof({var_name});")
            c_source.append("")
            
            generated_arrays.append(var_name)

    # Generate Registry (Array of Pointers)
    # This allows C code to loop through all PDRs without knowing their names
    c_source.append("/* --- PDR Registry --- */")
    c_source.append("typedef struct {")
    c_source.append("    const uint8_t* data;")
    c_source.append("    size_t size;")
    c_source.append("} pdr_entry_t;")
    c_source.append("")
    c_source.append("const pdr_entry_t pdr_registry[] = {")
    
    for name in generated_arrays:
        c_source.append(f"    {{ {name}, {name}_size }},")
    
    c_source.append("};")
    c_source.append("")
    c_source.append(f"const size_t pdr_registry_count = {len(generated_arrays)};")

    # Write output
    output_dir = os.path.dirname(output_file)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)

    with open(output_file, 'w') as f:
        f.write("\n".join(c_source))

    print(f"Success! Generated {output_file} containing {len(generated_arrays)} PDRs.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate C code from directory of PLDM YAMLs")
    parser.add_argument("yaml_dir", help="Directory containing .yaml files")
    parser.add_argument("schema_dir", help="Directory containing .json schema files")
    parser.add_argument("out", help="Output .c file path")

    args = parser.parse_args()
    generate_all(args.yaml_dir, args.schema_dir, args.out)
